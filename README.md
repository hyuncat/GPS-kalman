# GPS-kalman
Scripts and web app to implement and visualize Kalman filtering for GPS time-series data.

## Installation notes

All non-road-snapping features can be run just by installing package dependencies:
```shell
pip install -r requirements.txt
```
For setting up OSRM backend service, download the Beijing .pbf file and follow the documentation on their GitHub for setting up the Docker daemon. When you run the container, use the following:

```shell
docker run -t -i -p 9000:5000 -v "${PWD}/osrm-backend/beijing:/data" osrm/osrm-backend osrm-routed --algorithm mld --max-matching-size 1000 /data/beijing-latest.osrm
```

This runs it with batch size 1000 and also on port 9000, which is the url which my functions send requests to.

## Notebook scripts

Current jupyter notebook scripts are found in `/notebooks`. All code can be tested with data from `/notebooks/data`, though if you want to run it with all the training data you should download a file `all_plt_data` from the project Google Drive.

The notebooks include code for the three following modes:

### 1. Kalman filtering GPS data

Our main, initial goal was to apply the Kalman filter with the pykalman library to smooth out some of the gaussian noise generated by GPS data.

<img width="557" src="https://github.com/hyuncat/GPS-kalman/assets/114366569/ae939e8e-4548-44a7-b804-a8352bb26c41">

We found it works pretty well in reducing the random noise of the GPS data.

#### About the Kalman Filter

The Kalman filter uses the following algorithm:

$$
\begin{align*}
x_{t+1}   &= A_{t} x_{t} + b_{t} + \text{Normal}(0, Q_{t}) \\
z_{t}     &= C_{t} x_{t} + d_{t} + \text{Normal}(0, R_{t})
\end{align*}
$$

Within pykalman itself, it's implemented with these two functions:

**Kalman Smoother** (`kf.smooth`) is an algorithm designed to estimate the probability of a given $x_t=(\text{lat}, \text{long})$ given all the observations from $0$ to $T-1$.
- $P(x_t | z_{0:T-1})$

The **Expectation-Maximization (EM)** algorithm aims to find the KF parameters within the observations which have the 'max expectation' or the greatest probability of occurring given all the observations for all timesteps.
- Given: $\theta = (A, b, C, d, Q, R, \mu_0, \Sigma_0)$
- Want to find: $\max_{\theta} P(z_{0:T-1}; \theta)$

### 2. Time segmentation

In the presence of large jumps in the GPS data, Kalman filtering tends to generate hallucinations which try to fill in the gaps when it may not be applicable. See the small red dots between groups below:

<img width="557" src="https://github.com/hyuncat/GPS-kalman/assets/114366569/d8783d83-97a5-4a08-b2c6-4d855544d3f0">

To avoid this we filter GPS data separately based on person, date, and by only filtering datapoints together if they are within 60 seconds (tunable) of each other. This seems to get rid of virtually all of these obvious hallucinations.

<img width="557" src="https://github.com/hyuncat/GPS-kalman/assets/114366569/f96eb95d-d3d2-46d3-a57b-58f3b4f6579d">

### 3. Road snapping

Currently hosting OSRM's backend match service to try and 'snap' the GPS data to the street grid. Different people have yielded varying levels of success, but for now we are running with a batch size of 1000 and playing around with radius sizes around 20, and finding okay results. Still needs a lot of work before we can use it in the model, and need to find a way to map the original time data back onto the snapped coordinates.

<img width="557" alt="Screenshot 2024-06-30 at 10 14 36 PM" src="https://github.com/hyuncat/GPS-kalman/assets/114366569/89c599b6-70d1-4e44-ba59-9ada35d3c199">

### 4. (A fourth type)

There is also a fourth notebook type, `map_visualization`, which tests the various workflows I attempted while trying to create an intuitive way to create a map visualization class. The current best map visualization class for now is in `notebooks/scripts/PlotMap.py`, and its sample usage can be found in the last few cells of `map_visualization.ipynb` and `road_snap2.ipynb`.



## Explore the data in the flask app

You can visualize the data (either full or demo) in a simple flask app to explore any given person's movement on all available dates they had walked. You can test this locally by running:

```shell
cd flask-app
python app.py
```

The app looks something like this:

<img width="557" alt="Screenshot 2024-06-30 at 10 44 19 PM" src="https://github.com/hyuncat/GPS-kalman/assets/114366569/266970cc-13c6-477b-adcf-230af8cb6dca">

For now it only shows the difference between original GPS and kalman filtered GPS data, but can (and should probably) be extended to incorporate time segmentation + road snapping to facilitate easier tuning of radius / batch size / etc.
